import numpy as np

'''
  ndarray 는 대규모 데이터 집합을 담을 수 있는 포괄적인 다차원 배열이다.
  데이터의 원소들은 같은 자료형이어야 하며,
  배열의 차원의 크기를 알려주는 shape 라는 튜플과 배열에 저장된 자료형을 알려주는 dtype 객체가 존재한다.
  ndim 의 경우 차원을 반환해준다.
'''


# 배열 생성
# array: 입력 데이터를 ndarray로 변환 -> 입력 데이터는 기본적으로 복사됨
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)

data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
# 해당 데이터로부터 형태를 추론하여 2차원 형태로 나오게 된다.
arr2 = np.array(data2)

print(arr1, '\n', arr2)
print(arr2.ndim)  # 2
print(arr1.dtype)  # float64

# zeros / ones
print(np.zeros(10))  # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
print(np.zeros((2, 3)))  # [[0. 0. 0.] [0. 0. 0.]]
print(np.ones(5))  # [1. 1. 1. 1. 1.]

# empty: 0으로 초기화된 배열을 반환하지 않고 가비지 값으로 채워진 배열을 반환한다
print(np.empty(10))  # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]

# full: 인자로 받은 dtype 과 배열의 모양을 생성하고 인자로 받은 값으로 배열을 채운다

# asarray: 입력 데이터를 ndarray로 변환하지만 입력 데이터가 이미 ndarray 일 경우 복사가 일어나진 않는다

# arange: 내장 range 함수와 유사하지만 리스트 대신 ndarray를 반환
print(np.arange(15))  # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]

# eye, identity: NxN 크기의 단위행렬을 생성한다. 좌상단 -> 우하단을 잇는 대각선은 1로 채워지고 나머지는 0으로 채워진다


'''
  디스크에서 데이터를 읽고 쓰기 편하도록 하위 레벨의 표현에 직접적으로 맞춰져 있어
  저수준 언어(C, 포트란 등)로 작성된 코드와 쉽게 연동이 가능해진다.
  산술 데이터의 dtype 은 float, int 같은 자료형의 이름과 하나의 원소가 차지하는 비트 수로 이뤄진다.
'''
# astype: 배열의 dtype 을 다른 형으로 명시적 형변환
arr = np.array([1, 2, 3, 4, 5])
print(arr.dtype)  # int64
float_arr = arr.astype(np.float64)
print(float_arr.dtype)  # float64

'''
  벡터화
  for 문을 작성하지 않고 데이터를 일괄 처리할 수 있다.
  1. 같은 크기의 배열 간 산술 연산은 배열의 각 원소 단위로 적용된다.
  2. 스칼라 인자가 포함된 산술 연산의 경우 배열 내 모든 원소에 스칼라 인자가 적용된다.
  3. 같은 크기를 가진 배열 간의 비교 연산이 가능하다.
    -> 크기가 다른 배열 간의 연산은 브로드캐스팅이라 한다.
'''

'''
  색인/슬라이싱
  1차원 배열은 리스트와 유사하게 동작한다.
'''
arr3 = np.arange(10)
print(arr3[5])  # 5
print(arr3[5:8])  # 5 6 7

# 브로드캐스팅: 배열 조각에 스칼라값을 대입하면 선택 영역 전체로 전파되는 현상
# 이 현상은 리스트와는 달리 원본 배열에 그대로 반영된다는 것이다. (데이터 복사가 일어나지 않음)
arr3[5:8] = 10
print(arr3)  # [ 0  1  2  3  4 10 10 10  8  9]

arr_slc = arr3[5:8]
print(arr_slc)  # 10 10 10

arr_slc[1] = 20
print(arr3)  # [ 0  1  2  3  4 10 20 10  8  9] <- 데이터의 복사가 일어남을 확인 가능
'''
  데이터의 복사가 자주 일어나는 다른 언어를 사용한다면 복사가 일어나지 않는 것이 특이점이다.
  이는 Numpy 의 설계상 대용량 데이터 처리를 염두했기 때문에 데이터 복사를 남발하면 성능과 메모리 문제로 인해 복사가 일어나지 않도록 설계된 것이다.
'''

# 원본 배열을 건들고 싶지 않다면 copy() 를 사용하여 명시적으로 배열 복사가 일어나도록 한다.
arr_slc2 = arr3[5:8].copy()
arr_slc2[2] = 50
print(arr3)  # [ 0  1  2  3  4 10 20 10  8  9] <- 데이터 복사가 일어나지 않음을 확인 가능

# [:]: 배열의 모든 값을 할당

# 다차원 배열
# 2차원 배열에선 각 색인에 해당하는 요소는 스칼라값이 아닌 1차원 배열이다.
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr2d[2])  # [7 8 9]

# 즉 2차원 배열에서 개별 요소에 접근하기 위해선 재귀적으로 접근해줘야 한다.
print(arr2d[2][0])  # 7
# ,를 사용하여 재귀적 접근과 동일한 결과를 유추할 수 있다.
print(arr2d[2, 0])  # 7
# 즉 첫번째 색인을 Row(행)으로, 두번째 색인을 Column(열)로 접근하는 것이다.

# 다차원 배열에서 마지막 색인을 생략하면 반환되는 객체는 상위 차원의 데이터를 포함하고 있는 한 차원 낮은 ndarray 가 된다.
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr3d.shape)  # (2, 2, 3)

print(arr3d[0].shape)  # (2, 3)
print(arr3d[1, 0])  # [7 8 9]
