import numpy as np

'''
  ndarray 는 대규모 데이터 집합을 담을 수 있는 포괄적인 다차원 배열이다.
  데이터의 원소들은 같은 자료형이어야 하며,
  배열의 차원의 크기를 알려주는 shape 라는 튜플과 배열에 저장된 자료형을 알려주는 dtype 객체가 존재한다.
  ndim 의 경우 차원을 반환해준다.
'''


# 배열 생성
# array: 입력 데이터를 ndarray로 변환 -> 입력 데이터는 기본적으로 복사됨
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)

data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
# 해당 데이터로부터 형태를 추론하여 2차원 형태로 나오게 된다.
arr2 = np.array(data2)

print(arr1, '\n', arr2)
print(arr2.ndim)  # 2
print(arr1.dtype)  # float64

# zeros / ones
print(np.zeros(10))  # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
print(np.zeros((2, 3)))  # [[0. 0. 0.] [0. 0. 0.]]
print(np.ones(5))  # [1. 1. 1. 1. 1.]

# empty: 0으로 초기화된 배열을 반환하지 않고 가비지 값으로 채워진 배열을 반환한다
print(np.empty(10))  # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]

# full: 인자로 받은 dtype 과 배열의 모양을 생성하고 인자로 받은 값으로 배열을 채운다

# asarray: 입력 데이터를 ndarray로 변환하지만 입력 데이터가 이미 ndarray 일 경우 복사가 일어나진 않는다

# arange: 내장 range 함수와 유사하지만 리스트 대신 ndarray를 반환
print(np.arange(15))  # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]

# eye, identity: NxN 크기의 단위행렬을 생성한다. 좌상단 -> 우하단을 잇는 대각선은 1로 채워지고 나머지는 0으로 채워진다


'''
  디스크에서 데이터를 읽고 쓰기 편하도록 하위 레벨의 표현에 직접적으로 맞춰져 있어
  저수준 언어(C, 포트란 등)로 작성된 코드와 쉽게 연동이 가능해진다.
  산술 데이터의 dtype 은 float, int 같은 자료형의 이름과 하나의 원소가 차지하는 비트 수로 이뤄진다.
'''
# astype: 배열의 dtype 을 다른 형으로 명시적 형변환
arr = np.array([1, 2, 3, 4, 5])
print(arr.dtype)  # int64
float_arr = arr.astype(np.float64)
print(float_arr.dtype)  # float64

'''
  벡터화
  for 문을 작성하지 않고 데이터를 일괄 처리할 수 있다.
  1. 같은 크기의 배열 간 산술 연산은 배열의 각 원소 단위로 적용된다.
  2. 스칼라 인자가 포함된 산술 연산의 경우 배열 내 모든 원소에 스칼라 인자가 적용된다.
  3. 같은 크기를 가진 배열 간의 비교 연산이 가능하다.
    -> 크기가 다른 배열 간의 연산은 브로드캐스팅이라 한다.
'''

'''
  색인/슬라이싱
  1차원 배열은 리스트와 유사하게 동작한다.
'''
arr3 = np.arange(10)
print(arr3[5])  # 5
print(arr3[5:8])  # 5 6 7

# 브로드캐스팅: 배열 조각에 스칼라값을 대입하면 선택 영역 전체로 전파되는 현상
# 이 현상은 리스트와는 달리 원본 배열에 그대로 반영된다는 것이다. (데이터 복사가 일어나지 않음)
arr3[5:8] = 10
print(arr3)  # [ 0  1  2  3  4 10 10 10  8  9]

arr_slc = arr3[5:8]
print(arr_slc)  # 10 10 10

arr_slc[1] = 20
print(arr3)  # [ 0  1  2  3  4 10 20 10  8  9] <- 데이터의 복사가 일어남을 확인 가능
'''
  데이터의 복사가 자주 일어나는 다른 언어를 사용한다면 복사가 일어나지 않는 것이 특이점이다.
  이는 Numpy 의 설계상 대용량 데이터 처리를 염두했기 때문에 데이터 복사를 남발하면 성능과 메모리 문제로 인해 복사가 일어나지 않도록 설계된 것이다.
'''

# 원본 배열을 건들고 싶지 않다면 copy() 를 사용하여 명시적으로 배열 복사가 일어나도록 한다.
arr_slc2 = arr3[5:8].copy()
arr_slc2[2] = 50
print(arr3)  # [ 0  1  2  3  4 10 20 10  8  9] <- 데이터 복사가 일어나지 않음을 확인 가능

# [:]: 배열의 모든 값을 할당

# 다차원 배열
# 2차원 배열에선 각 색인에 해당하는 요소는 스칼라값이 아닌 1차원 배열이다.
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr2d[2])  # [7 8 9]

# 즉 2차원 배열에서 개별 요소에 접근하기 위해선 재귀적으로 접근해줘야 한다.
print(arr2d[2][0])  # 7
# ,를 사용하여 재귀적 접근과 동일한 결과를 유추할 수 있다.
print(arr2d[2, 0])  # 7
# 즉 첫번째 색인을 Row(행)으로, 두번째 색인을 Column(열)로 접근하는 것이다.

# 다차원 배열에서 마지막 색인을 생략하면 반환되는 객체는 상위 차원의 데이터를 포함하고 있는 한 차원 낮은 ndarray 가 된다.
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr3d.shape)  # (2, 2, 3)

print(arr3d[0].shape)  # (2, 3)
print(arr3d[1, 0])  # [7 8 9]


# 슬라이스
# 축을 따라 선택한 영역 내 요소를 선택
print(arr2d[:2])  # [[1 2 3] [4 5 6]]
print(arr2d[:2, 1:])  # [[2 3] [5 6]]
# 슬라이싱을 해서 같은 차원의 배열에 대한 뷰를 얻을 수 있다

print(arr2d[2])  # [7 8 9]
print(arr2d[2, :])  # [7 8 9]
print(arr2d[2:, :])  # [[7 8 9]]


# np.random.randn()
names = np.array(['Bob', 'Joe', 'Bob', 'Bob', 'Will', 'Joe', 'Joe'])
data = np.random.randn(7, 4)  # 7 Row, 4 Colum 의 랜덤값
print(data)

print(names == 'Bob')  # [ True False True True False False False]

print(data[names == 'Bob'])  # Boolean 값을 기반으로 Row가 True 인 data Row 가 출력
# 불리언 배열은 반드시 색인하려는 축의 길이와 동일한 길이를 가져야한다
# 물론 배열의 크기가 달라서 실패하지 않는다
print(~(names == 'Bob'))  # [False  True False False  True  True  True]
print(data[~(names == 'Bob'), 2:])

# 배열에 불리언 색인을 이용하여 데이터를 선택하면 반환되는 배열의 내용이 바뀌지 않더라도 데이터 복사가 발생한다
# 불리언 배열에서는 and, or 대신 &, | 를 사용한다


'''
  팬시 색인
  정수 배열을 사용한 색인을 설명하기 위한 용어
  슬라이싱과 달리 선택된 데이터를 새로운 배열로 복사한다
'''
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i

print(arr)
# [[0. 0. 0. 0.] [1. 1. 1. 1.] [2. 2. 2. 2.] [3. 3. 3. 3.] [4. 4. 4. 4.] [5. 5. 5. 5.] [6. 6. 6. 6.] [7. 7. 7. 7.]]

# 특정 순서의 Row 를 선택하고자 한다면 순서가 명시된 정수가 담긴 리스트를 넘긴다
print(arr[[4, 3, 0]])  # [[4. 4. 4. 4.] [3. 3. 3. 3.] [0. 0. 0. 0.]]

# 색인으로 음수를 사용하면 끝에서부터 Row 를 선택한다
print(arr[[-5, -7]])  # [[3. 3. 3. 3.] [1. 1. 1. 1.]]


arr = np.arange(32).reshape((8, 4))
# 다차원 색인 배열은 각각의 색인 튜플에 대응하는 1차원 배열이 선택된다
print(arr[[1, 5, 7, 2], [0, 3, 1, 2]])
# (1, 0), (5, 3), (7, 1), (2, 2) -> [ 4 23 29 10]
# 팬시 색인의 결과는 항상 1차원이 된다


# 배열 전치와 축 바꾸기
# 배열 전치: 데이터를 복사하지 않고 데이터의 모양이 바뀐 뷰를 반환하는 기능
# ndarray 에는 transpose 메서드와 T 라는 이름의 특수한 속성을 가지고 있다
arr = np.arange(15).reshape((3, 5))
print(arr.T)  # [[ 0  5 10] [ 1  6 11] [ 2  7 12] [ 3  8 13] [ 4  9 14]]
print(arr.transpose())
# [[ 0  5 10] [ 1  6 11] [ 2  7 12] [ 3  8 13] [ 4  9 14]]

# 이 속성/메서드는 행렬 계산에 자주 사용된다.
# 행렬의 내적 곱
arr = np.random.randn(6, 3)
print(np.dot(arr.T, arr))

# 다차원 배열의 경우 transpose() 메서드는 튜플로 축 번호를 받아서 치환한다
arr = np.arange(16).reshape((2, 2, 4))
print(arr)  # [[[ 0  1  2  3] [ 4  5  6  7]] [[ 8  9 10 11] [12 13 14 15]]]

# swapaxes 메서드는 두 개의 축 번호를 받아서 배열을 뒤바꾼다
print(arr.swapaxes(1, 2))
# [[[ 0  4] [ 1  5] [ 2  6] [ 3  7]] [[ 8 12] [ 9 13] [10 14] [11 15]]]
